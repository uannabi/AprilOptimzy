{"id":128055,"url":"http://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction","text":"Reed-Solomon error correction is a forward error correction code. It works by oversampling a polynomial constructed from the data. The polynomial is evaluated at several points, and these values are sent or recorded. Sampling the polynomial more often than is necessary makes the polynomial over-determined. As long as it receives \"many\" of the points correctly, the receiver can recover the original polynomial even in the presence of a \"few\" bad points.\nReed-Solomon codes are used in many different kinds of commercial applications, for example in CDs, DVDs and Blu-ray Discs, in data transmission technologies such as DSL & WiMAX, and broadcast systems such as DVB and ATSC.\nOverview.\nReed-Solomon codes are block codes. This means that a fixed block of input data is processed\ninto a fixed block of output data. In the case of the most commonly used R-S code (255, 223) \u2013 223 Reed-Solomon input symbols (each eight bits long) are encoded into 255 output symbols.\nThe Reed-Solomon code, like the convolutional code, is a transparent code. This means that if\nthe channel symbols have been inverted somewhere along the line, the decoders will still\noperate. The result will be the complement of the original data. However, the Reed-Solomon\ncode loses its transparency if virtual zero fill is used. For this reason it is mandatory that the\nsense of the data (i.e., true or complemented) be resolved before Reed-Solomon decoding.\nIn the case of the Voyager program R-S codes reach near optimal performance when concatenated with the (7, 1/2) convolutional (Viterbi) inner code. Since two check symbols are required for each error to be corrected, this results in a total of 32 check symbols and 223 information symbols per codeword.\nIn addition, the Reed-Solomon codewords can be interleaved on a symbol basis before being\nconvolutionally encoded. Since this separates the symbols in a codeword, it becomes less likely\nthat a burst from the Viterbi decoder disturbs more than one Reed-Solomon symbol in any one\nBasic idea.\nThe key idea behind a Reed-Solomon code is that the data encoded is first visualized as a polynomial. The code relies on a theorem from algebra that states that any \"k\" distinct points \"uniquely\" determine a polynomial of degree at most \"k\"-1.\nThe sender determines a degree formula_1 polynomial, over a finite field, that represents the formula_1 data points. The polynomial is then \"encoded\" by its evaluation at various points, and these values are what is actually sent. During transmission, some of these values may become corrupted. Therefore, more than \"k\" points are actually sent. As long as enough values are received correctly, the receiver can deduce what the original polynomial was, and decode the original data.\nIn the same sense that one can correct a curve by interpolating past a gap, a Reed-Solomon code can bridge a series of errors in a block of data to recover the coefficients of the polynomial that drew the original curve.\nHistory.\nThe code was invented in 1960 by Irving S. Reed and Gustave Solomon, who were then members of MIT Lincoln Laboratory. Their seminal article was entitled \"Polynomial Codes over Certain Finite Fields.\" When it was written, digital technology was not advanced enough to implement the concept. The first application, in 1982, of RS codes in mass-produced products was the compact disc, where two interleaved RS codes are used. An efficient decoding algorithm for large-distance RS codes was developed by Elwyn Berlekamp and James Massey in 1969. Today RS codes are used in hard disk drive, DVD, telecommunication, and digital broadcast protocols.","categories":[],"infobox_types":[],"annotations":[{"uri":"Forward_error_correction","surface_form":"forward error correction","offset":35},{"uri":"Oversampling","surface_form":"oversampling","offset":78},{"uri":"Polynomial","surface_form":"polynomial","offset":93},{"uri":"Information","surface_form":"data","offset":125},{"uri":"Compact_disc","surface_form":"CDs","offset":551},{"uri":"DVD","surface_form":"DVD","offset":556},{"uri":"Blu-ray_Disc","surface_form":"Blu-ray Disc","offset":565},{"uri":"DSL","surface_form":"DSL","offset":622},{"uri":"WiMAX","surface_form":"WiMAX","offset":628},{"uri":"Digital_Video_Broadcasting","surface_form":"DVB","offset":665},{"uri":"ATSC_Standards","surface_form":"ATSC","offset":673},{"uri":"Block_code","surface_form":"block code","offset":712},{"uri":"Convolutional_code","surface_form":"convolutional code","offset":1000},{"uri":"Voyager_program","surface_form":"Voyager program","offset":1449},{"uri":"Polynomial","surface_form":"polynomial","offset":2113},{"uri":"Theorem","surface_form":"theorem","offset":2146},{"uri":"Algebra","surface_form":"algebra","offset":2159},{"uri":"Degree_of_a_polynomial","surface_form":"degree","offset":2245},{"uri":"Finite_field","surface_form":"finite field","offset":2327},{"uri":"Interpolation","surface_form":"interpolating","offset":2800},{"uri":"Irving_S._Reed","surface_form":"Irving S. Reed","offset":3013},{"uri":"Gustave_Solomon","surface_form":"Gustave Solomon","offset":3032},{"uri":"MIT","surface_form":"MIT","offset":3074},{"uri":"Lincoln_Laboratory","surface_form":"Lincoln Laboratory","offset":3078},{"uri":"Compact_disc","surface_form":"compact disc","offset":3348},{"uri":"Berlekamp-Massey_algorithm","surface_form":"decoding algorithm","offset":3416},{"uri":"Elwyn_Berlekamp","surface_form":"Elwyn Berlekamp","offset":3480},{"uri":"James_Massey","surface_form":"James Massey","offset":3500},{"uri":"Hard_disk_drive","surface_form":"hard disk drive","offset":3549},{"uri":"DVD","surface_form":"DVD","offset":3566}]}