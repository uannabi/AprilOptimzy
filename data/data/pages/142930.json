{"id":142930,"url":"http://en.wikipedia.org/wiki/Closure_(computer_science)","text":"In computer science, a closure is a function that has an environment of its own. In this environment, there is at least one bound variable (a name that has a \"value\", such as a number). The closure's environment keeps the bound variables in memory between uses of the closure.\nPeter J. Landin\u00A0gave this idea the name \"closure\"\u00A0in 1964. The Scheme programming language made closures popular after 1975. Many programming languages made after that time have closures.\nAnonymous functions (functions with no name) are sometimes wrongly called closures. Most languages that have anonymous functions also have closures. An anonymous function is also a closure if it has an environment of its own with at least one bound variable. An anonymous function with no environment of its own is not a closure. A named closure is not anonymous.\nClosures and first-class functions.\n\"Values\" may be numbers or some other type of data, such as letters, or data structures made up of simpler parts. In the rules of a programming language, the first-class values are values that can be given to functions, returned by functions, and bound to a variable name. Functions that take or return other functions are called higher-order functions. Most languages that have functions as first-class values also have higher-order functions and closures.\nIn this example, the lambda expression codice_2 is part of the function codice_2. When the function is run, Scheme must make the value of the lambda. It does this by making a closure with the code for the lambda and a reference to the codice_2 variable, which is a free variable inside the lambda. (A \"free variable\" is a name that is not bound to a value.)\nThe codice_2 function then runs the closure on each book in the list to pick which books to return. Because the closure itself has a reference to codice_2, the closure can use that value each time codice_2 runs the closure. The function codice_2 itself might be written in a completely separate file.\n// Return a list of all books with at least 'threshold' copies sold.\nECMAScript uses the word codice_2 here instead of codice_2, and the codice_2 method in place of the codice_2 function, but otherwise the code does the same thing in the same way.\nA function may create a closure and return it. The following example is a function that returns a function.\n// Return a function that approximates the derivative of f\n// using an interval of dx, which should be appropriately small.\nThe closure environment keeps the bound variables codice_2 and codice_2 after the \"enclosing\" function (codice_2) returns. In languages without closures, these values would be lost after the enclosing function returns. In languages with closures, a bound variable must be kept in memory as long as any closure has it.\nreturn (f(x + dx) - f(x)) / dx\nIn this example, the function named \"gradient\" makes a closure together with the variables \"f\" and \"dx\". The outer enclosing function named \"derivative\" returns this closure. In this case, an anonymous function would work also.<syntaxhighlight lang=\"Python\">\nreturn lambda x: (f(x + dx) - f(x)) / dx\n</syntaxhighlight>Python must often use named functions instead because its lambda expressions may only contain other \"expressions\" (code that returns a value) and not \"statements\" (code that has effects but no value). But in other languages, such as Scheme, all code returns a value; in Scheme, everything is an expression.\nUses of closures.\n(display (bar)); prints \"meet me by the docks at midnight\"\nNote: Some speakers call any data structure that binds a lexical environment a closure, but the term usually refers specifically to functions.","categories":[],"infobox_types":[],"annotations":[{"uri":"Computer_science","surface_form":"computer science","offset":3},{"uri":"Function","surface_form":"function","offset":36},{"uri":"Environment","surface_form":"environment","offset":57},{"uri":"Bound_variable","surface_form":"bound variable","offset":124},{"uri":"Scheme_(programming_language)","surface_form":"Scheme","offset":340},{"uri":"Programming_language","surface_form":"programming language","offset":347},{"uri":"Anonymous_function","surface_form":"Anonymous functions","offset":465},{"uri":"Data","surface_form":"data","offset":911},{"uri":"Data_structure","surface_form":"data structures","offset":937},{"uri":"First-class_function","surface_form":"first-class values","offset":1023},{"uri":"Higher-order_function","surface_form":"higher-order functions","offset":1195},{"uri":"Anonymous_function","surface_form":"lambda expression","offset":1344},{"uri":"Free_variable","surface_form":"free variable","offset":1588},{"uri":"Lexical","surface_form":"lexical","offset":3570}]}