{"id":208030,"url":"http://en.wikipedia.org/wiki/Minimum_spanning_tree","text":"A number of problems from graph theory are called Minimum spanning tree. In graph theory, a tree is a way of connecting all the vertices together, so that there is exactly one path from any one vertex, to any other vertex of the tree. If the graph represents a number of cities connected by roads, one could select a number of roads, so that each city can be reached from every other, but that there is no more than one way to travel from one city to another.\nA graph can have more than one spanning tree, just like there may be more than one way to select the roads between the cities.\nMost of the time, graphs are weighted; each connection between two cities has a weight: It might cost something to travel on a given road, or one connection may be longer than the other, this means it takes more time to travel on that connection. In the language of graph theory, the connections are called \"edges\".\nA minimum spanning tree is a tree. It is different from other trees in that it minimizes the total of the \"weights\" attached to the edges. Depending on what the graph looks like, there may be more than one minimum spanning tree. In a graph where all the edges have the same weight, every tree is a minimum spanning tree. If all the edges have different weights (that is: there are no two edges with the same weight), there is exactly one minimal spanning tree.\nA first try.\nfind the minimum weighted edge in \"E\" that is safe for \"T\"\nIn this case, \"safe\" means that including the edge does not form a cycle in the graph. A cycle means starting at a vertex, travelling to a number of other vertices and ending up at the starting point again without using the same edge twice.\nHistory.\nCzech scientist Otakar Bor\u016Fvka developed the first known algorithm for finding a minimum spanning tree, in 1926. He wanted to solve the problem of finding an efficient coverage of Moravia with electricity. Today, this algorithm is known as Bor\u016Fvka's algorithm.\nTwo other algorithms are commonly used today. One of them was developed by Vojt\u011Bch Jarn\u00EDk in 1930, and put in practice by Robert Clay Prim in 1957. Edsger Wybe Dijkstra rediscovered it in 1959, and called it Prim's algorithm. The other algorithm is called Kruskal's algorithm, and was pulbished by Joseph Kruskal in 1956. All three algorithms are greedy, and run in polynomial time.\nThe fastest minimum spanning tree algorithm to date was developed by Bernard Chazelle. The algorithm is based on the soft heap,\nan approximate priority queue.\nIts running time is \"O\"(\"m\"\u00A0\u03B1(\"m\",\"n\")), where \"m\" is the number of edges, \"n\" is the number of vertices and \u03B1 is the classical functional inverse of the Ackermann function. The function \u03B1 grows extremely slowly, so that for all practical purposes it may be considered a constant no greater than 4; thus Chazelle's algorithm takes very close to linear time.\nWhat is the fastest possible algorithm for this problem? That is one of the oldest open questions in computer science. There is clearly a linear lower bound, since we must at least examine all the weights. If the edge weights are integers with a bounded bit length, then deterministic algorithms are known with linear running time.\nFor general weights, there are randomized algorithms whose \"expected\" running time is linear.\nThe problem can also be approached in a distributed manner. If each node is considered a computer and no node knows anything except its own connected links, one can still calculate the distributed minimum spanning tree.","categories":[],"infobox_types":[],"annotations":[{"uri":"Graph_theory","surface_form":"graph theory","offset":26},{"uri":"Tree_(graph_theory)","surface_form":"tree","offset":92},{"uri":"Vertex","surface_form":"vertices","offset":128},{"uri":"City","surface_form":"cities","offset":271},{"uri":"Road","surface_form":"road","offset":291},{"uri":"Czech_Republic","surface_form":"Czech","offset":1686},{"uri":"Scientist","surface_form":"scientist","offset":1692},{"uri":"Otakar_Bor%C5%AFvka","surface_form":"Otakar Bor\u016Fvka","offset":1702},{"uri":"Moravia","surface_form":"Moravia","offset":1866},{"uri":"Electricity","surface_form":"electricity","offset":1879},{"uri":"Bor%C5%AFvka%27s_algorithm","surface_form":"Bor\u016Fvka's algorithm","offset":1926},{"uri":"Vojt%C4%9Bch_Jarn%C3%ADk","surface_form":"Vojt\u011Bch Jarn\u00EDk","offset":2022},{"uri":"Robert_C._Prim","surface_form":"Robert Clay Prim","offset":2069},{"uri":"Edsger_W._Dijkstra","surface_form":"Edsger Wybe Dijkstra","offset":2095},{"uri":"Prim%27s_algorithm","surface_form":"Prim's algorithm","offset":2155},{"uri":"Kruskal%27s_algorithm","surface_form":"Kruskal's algorithm","offset":2203},{"uri":"Joseph_Kruskal","surface_form":"Joseph Kruskal","offset":2245},{"uri":"Greedy_algorithms","surface_form":"greedy","offset":2294},{"uri":"Polynomial","surface_form":"polynomial","offset":2313},{"uri":"Bernard_Chazelle","surface_form":"Bernard Chazelle","offset":2399},{"uri":"Soft_heap","surface_form":"soft heap","offset":2447},{"uri":"Priority_queue","surface_form":"priority queue","offset":2473},{"uri":"Big_O_notation","surface_form":"O","offset":2510},{"uri":"Ackermann_function","surface_form":"Ackermann function","offset":2643},{"uri":"Randomized_algorithm","surface_form":"randomized algorithm","offset":3210},{"uri":"Expected_value","surface_form":"expected","offset":3239},{"uri":"Distributed_minimum_spanning_tree","surface_form":"distributed minimum spanning tree","offset":3458}]}