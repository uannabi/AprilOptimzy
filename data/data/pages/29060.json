{"id":29060,"url":"http://en.wikipedia.org/wiki/RSA_algorithm","text":"RSA (Rivest\u2013Shamir\u2013Adleman) is an algorithm used by modern computers to encrypt and decrypt messages. It is an asymmetric cryptographic algorithm. Asymmetric means that there are two different keys. This is also called public key cryptography, because one of the keys can be given to anyone. The other key must be kept private. The algorithm is based on the fact that finding the factors of a large composite number is difficult: when the factors are prime numbers, the problem is called prime factorization. It is also a key pair (public and private key) generator.\nThe public key is made of the modulus formula_1 and the public (or encryption) exponent formula_1.\nThe personal key is made of p,q and the private (or decryption) exponent formula_1 which must be kept secret.\nEncrypting message.\nAlice gives her public key (formula_1 & formula_1) to Bob and keeps her private key secret. Bob wants to send message M to Alice.\nThis can be done quickly using the method of exponentiation by squaring. Bob then sends formula_1 to Alice.\nDecrypting message.\nGiven formula_1, she can recover the original distinct prime numbers, applying the Chinese remainder theorem to these two congruences yields\nA working example.\nHere is an example of RSA encryption and decryption. The prime numbers used here are too small to let us securely encrypt anything. You can use OpenSSL to generate and examine a real keypair.\nFor example, to encrypt formula_1, we calculate\nTo decrypt formula_1, we calculate\nBoth of these calculations can be computed fast and easily using the square-and-multiply algorithm for.\nDeriving RSA equation from Euler's theorem.\nRSA can easily be derived using Euler's theorem and Euler's totient function.\nStarting with Euler's theorem,formula_1we must show that decrypting an encrypted message, with the correct key, will give the original message.\nGiven a padded message \"m\", the ciphertext \"c\", is calculated byformula_1Substituting into the decryption algorithm, we haveformula_1We want to show this value is also congruent to \"m\".\nThe values of \"e\" and \"d\" were chosen to satify,formula_1Which is to say, there exists some integer \"k\", such thatformula_1Now we substitute into the encrypted then decrypted message,formula_1We apply Euler's theorem, and achive the result.formula_1\nPadding schemes.\nIn practice, the first two problems can arise when short ASCII messages are sent. In such messages, \"m\" might be the concatenation of one or more ASCII-encoded character(s). A message consisting of a single ASCII codice_2 character (whose numeric value is 0) would be encoded as \"m\" = 0, which produces a ciphertext of 0 no matter which values of \"e\" and \"N\" are used. Likewise, a single ASCII codice_2 (whose numeric value is 1) would always produce a ciphertext of 1. For systems which conventionally use small values of \"e\", such as 3, all single character ASCII messages encoded using this scheme would be insecure, since the largest \"m\" would have a value of 255, and 2553 is less than any reasonable modulus. Such plaintexts could be recovered by simply taking the cube root of the ciphertext.\nTo avoid these problems, practical RSA implementations typically embed some form of structured, randomized padding into the value \"m\" before encrypting it. This padding ensures that \"m\" does not fall into the range of insecure plaintexts, and that a given message, once padded, will encrypt to one of a large number of different possible ciphertexts. The latter property can increase the cost of a dictionary attack beyond the capabilities of a reasonable attacker.\nStandards such as PKCS have been carefully designed to securely pad messages prior to RSA encryption. Because these schemes pad the plaintext \"m\" with some number of additional bits, the size of the un-padded message \"M\" must be somewhat smaller. RSA padding schemes must be carefully designed so as to prevent sophisticated attacks. This may be made easier by a predictable message structure. Early versions of the PKCS standard used constructions, which were later found vulnerable to a practical adaptive chosen ciphertext attack. Modern constructions use secure techniques such as Optimal Asymmetric Encryption Padding (OAEP) to protect messages while preventing these attacks. The PKCS standard also has processing schemes designed to provide additional security for RSA signatures, e.g., the Probabilistic Signature Scheme for RSA (RSA-PSS).\nSigning messages.\nSuppose Alice uses Bob's public key to send him an encrypted message. In the message, she can claim to be Alice but Bob has no way of verifying that the message was actually from Alice since anyone can use Bob's public key to send him encrypted messages. So, in order to verify the origin of a message, RSA can also be used to sign a message.\nSuppose Alice wishes to send a signed message to Bob. She produces a hash value of the message, raises it to the power of \"d\" mod \"n\" (just like when decrypting a message), and attaches it as a \"signature\" to the message. When Bob receives the signed message, he raises the signature to the power of \"e\" mod \"n\" (just like encrypting a message), and compares the resulting hash value with the message's actual hash value. If the two agree, he knows that the author of the message was in possession of Alice's secret key, and that the message has not been tampered with since.\nNote that secure padding schemes such as RSA-PSS are as essential for the security of message signing as they are for message encryption, and that the same key should never be used for both encryption and signing purposes.","categories":[],"infobox_types":[],"annotations":[{"uri":"Algorithm","surface_form":"algorithm","offset":34},{"uri":"Encryption","surface_form":"encrypt","offset":72},{"uri":"Cryptography","surface_form":"cryptographic","offset":122},{"uri":"Algorithm","surface_form":"algorithm","offset":136},{"uri":"Key_(cryptography)","surface_form":"keys","offset":193},{"uri":"Public-key_cryptography","surface_form":"public key cryptography","offset":219},{"uri":"Factorization","surface_form":"factors","offset":380},{"uri":"Composite_number","surface_form":"composite number","offset":399},{"uri":"Prime_number","surface_form":"prime number","offset":451},{"uri":"Prime_factorization","surface_form":"prime factorization","offset":488},{"uri":"Exponentiation_by_squaring","surface_form":"exponentiation by squaring","offset":971},{"uri":"Chinese_remainder_theorem","surface_form":"Chinese remainder theorem","offset":1137},{"uri":"Cryptography/Generate_a_keypair_using_OpenSSL","surface_form":"use OpenSSL to generate and examine a real keypair","offset":1354},{"uri":"Binary_exponentiation","surface_form":"square-and-multiply algorithm","offset":1558},{"uri":"Euler%27s_totient_theorem","surface_form":"Euler's theorem","offset":1669},{"uri":"Euler%27s_totient_function","surface_form":"Euler's totient function","offset":1689},{"uri":"Euler%27s_totient_theorem","surface_form":"Euler's theorem","offset":2246},{"uri":"ASCII","surface_form":"ASCII","offset":2369},{"uri":"PKCS","surface_form":"PKCS","offset":3596},{"uri":"Adaptive_chosen_ciphertext_attack","surface_form":"adaptive chosen ciphertext attack","offset":4077},{"uri":"Optimal_asymmetric_encryption_padding","surface_form":"Optimal Asymmetric Encryption Padding","offset":4163},{"uri":"PKCS","surface_form":"PKCS","offset":4264},{"uri":"RSA-PSS","surface_form":"RSA-PSS","offset":4416},{"uri":"Digital_signature","surface_form":"sign","offset":4771},{"uri":"Cryptographic_hash_function","surface_form":"hash value","offset":4856},{"uri":"RSA-PSS","surface_form":"RSA-PSS","offset":5404}]}