{"id":368829,"url":"http://en.wikipedia.org/wiki/Programming_paradigm","text":"Programming paradigms are a way of grouping programming languages by what they do. Languages can be in more than one paradigm.\nSome paradigms look at the way the code is run, such as allowing side effects, or having to do things in a certain order. Other paradigms look at the way that code is grouped, such as putting code into one or two pieces (or instead, many small pieces). Some other paradigms look at the order and pieces that make the program the way it is.\nThere are two main groups of paradigms, imperative and declarative. A language can be both at the same time.\nImperative programming.\nIn imperative programs, programmers give the computer a set of ordered steps that need to be done in order to do something. If someone wanted the computer to draw a cat face, they might give directions like \"Draw a circle here, draw two smaller circles there, draw two triangles on top\" and so on. Imperative programs sometimes have a lot of side effects.\nDeclarative programming.\nIn declarative paradigms, the programmer tells the computer what to do instead of how to do it. If they wanted the computer to draw a cat face, they might give directions like \"Draw a face, draw two eyes, two ears, and a mouth\".\nOther paradigms.\nSome paradigms can be found in both imperative \"and\" declarative languages. These paradigms are usually found with one of the above paradigms instead of going on their own.\nOverview.\nProgramming languages are grouped by paradigms in the same way that machines might be grouped by what they're used for.\nHaving more paradigms is not always good. One time that having less paradigms can be a good thing is when there is a language that is only functional. A function in one of these languages sometimes does less work (like only going over the parts of a group of things it actually needs to) than it might have to if the language was also procedural.\nMany programming paradigms are as well known for the things they \"do not\" let people do as for those they \"do\" let people do. One time where this is true is functional languages. When a functional language is \"only\" or \"mostly\" functional, it usually will not allow side-effects. Another time where this is true is structured programming: it is different from normal imperative languages because it does not let programmers use \"goto statements\" (statements telling the program to go to an earlier step). Because of this and other reasons, people sometimes think new paradigms do not allow enough things. It is sometimes okay for the computer to not let people do things, though: it can help people avoid problems with their code, and let the computer make guesses that so it can run code faster, or even check code for problems before the code runs!\nProblems with paradigms.\nSome people who study programming languages do not like that paradigms are used to group programming languages, such as Harper and Krishnamurthi. Those people say that a lot of programming languages can't just be grouped into paradigms because languages borrow things and ideas from lots of paradigms.\nHistory.\nNew paradigms have been created over time, and people either pointed them out at the time, or when looking back. One of the first paradigms that was recognized as a new way of programming was structured programming from the 1960s. The idea of a \"programming paradigm\" is from 1978 if not earlier, when Robert W. Floyd used it while teaching. The word \"paradigm\" in the way Robert meant it was first used by Thomas Kuhn in his book, \"The Structure of Scientific Revolutions\" (1962).\nMachine code.\nThe lowest-level (closest to how the computer likes to understand things) and oldest programming paradigm is machine code, an imperative paradigm. The directions in machine code are just a set of numbers in a certain order. Assembly language is a little bit less low-level (and a little bit less old). In assembly language, the directions for the computer are given mnemonics (easier-to-remember names), and memory addresses (directions to find a piece of information in the computer) can be given names. These are sometimes called first- and second-generation languages.\nIn the 1960s, assembly languages were made better by adding new things like library COPY, macros (bits of \"special\" code that got transformed to normal code before the program started running), running procedures (sets of directions given a name and saved for later), and variables (items given names and saved for later) from outside the program. This let people use some code in more than one project, and not have to worry about with hardware-specific problems (problems that only happen one one kind of computer) thanks to commands (names for directions) like READ/WRITE/GET/PUT.\nAssembly was, and sometimes still is, used in systems where it is important for the code to be fast, and it is also used a lot in embedded systems because lets the user have exact control of what the machine does.\nProcedural languages.\nIn the very late 1960s, people started inventing procedural languages. These third-generation languages (the first few of what we now call high-level languages) had words related to what they were trying to solve. For example,\nObject-oriented programming.\nAfter many people had started using procedural languages, they invented object-oriented programming languages. In these languages, data and its \"methods\" (ways of manipulating the data) are put in one \"object\". Some programmers, such as Richard Stallman, do not agree that object-oriented languages are better for explaining ideas to a computer than procedural languages.\nBecause object-oriented programming is a paradigm, not a language, people have made object oriented assembly languages like HLA (High Level Assembly).\nDeclarative paradigms.\nAt the same time, some people were making declarative programming languages. A language that is well known for being declarative is SQL (a language for adding and removing things from tables).","categories":[],"infobox_types":[],"annotations":[{"uri":"Paradigm","surface_form":"paradigm","offset":12},{"uri":"Programming_language","surface_form":"programming language","offset":44},{"uri":"Side_effect_(computer_science)","surface_form":"side effects","offset":192},{"uri":"Monolithic_system","surface_form":"putting code into one or two pieces","offset":311},{"uri":"Modular_programming","surface_form":"many small pieces","offset":360},{"uri":"Syntax","surface_form":"order","offset":413},{"uri":"Grammar","surface_form":"pieces","offset":423},{"uri":"Programmer","surface_form":"programmer","offset":624},{"uri":"Triangle","surface_form":"triangle","offset":869},{"uri":"Side_effect_(computer_science)","surface_form":"side effects","offset":942},{"uri":"Programmer","surface_form":"programmer","offset":1011},{"uri":"Functional_programming","surface_form":"functional","offset":1669},{"uri":"Function_(mathematics)","surface_form":"function","offset":1683},{"uri":"Procedure_(computer_science)","surface_form":"procedural","offset":1865},{"uri":"Side-effect_(computer_science)","surface_form":"side-effects","offset":2143},{"uri":"Structured_programming","surface_form":"structured programming","offset":2192},{"uri":"Imperative_programming","surface_form":"imperative languages","offset":2244},{"uri":"Goto","surface_form":"goto statements","offset":2306},{"uri":"Static_typing","surface_form":"check code for problems before the code runs","offset":2682},{"uri":"Structured_programming","surface_form":"structured programming","offset":3256},{"uri":"Robert_W._Floyd","surface_form":"Robert W. Floyd","offset":3366},{"uri":"Thomas_Kuhn","surface_form":"Thomas Kuhn","offset":3471},{"uri":"The_Structure_of_Scientific_Revolutions","surface_form":"The Structure of Scientific Revolutions","offset":3497},{"uri":"Low-level_programming_language","surface_form":"lowest-level","offset":3564},{"uri":"Machine_code","surface_form":"machine code","offset":3669},{"uri":"Imperative_programming","surface_form":"imperative","offset":3686},{"uri":"Instruction_set","surface_form":"directions","offset":3711},{"uri":"Assembly_language","surface_form":"Assembly language","offset":3784},{"uri":"Low-level_programming_language","surface_form":"low-level","offset":3823},{"uri":"Mnemonic","surface_form":"mnemonic","offset":3926},{"uri":"Memory_address","surface_form":"memory address","offset":3968},{"uri":"First-generation_programming_language","surface_form":"first-","offset":4092},{"uri":"Second-generation_programming_language","surface_form":"second-generation","offset":4103},{"uri":"Macro_(computer_programming)","surface_form":"macros","offset":4222},{"uri":"Subroutine","surface_form":"procedures","offset":4334},{"uri":"Variable","surface_form":"variable","offset":4404},{"uri":"Embedded_system","surface_form":"embedded system","offset":4846},{"uri":"Procedural_language","surface_form":"procedural language","offset":5001},{"uri":"Third-generation_programming_language","surface_form":"third-generation","offset":5029},{"uri":"High-level_programming_language","surface_form":"high-level languages","offset":5091},{"uri":"Procedural_languages","surface_form":"procedural languages","offset":5244},{"uri":"Object-oriented_programming","surface_form":"object-oriented programming","offset":5280},{"uri":"Data","surface_form":"data","offset":5339},{"uri":"Object_(computer_science)","surface_form":"object","offset":5410},{"uri":"Richard_Stallman","surface_form":"Richard Stallman","offset":5445},{"uri":"Assembly_language","surface_form":"assembly language","offset":5680},{"uri":"High_Level_Assembly","surface_form":"HLA (High Level Assembly","offset":5704},{"uri":"Declarative_programming","surface_form":"declarative programming languages","offset":5796},{"uri":"SQL","surface_form":"SQL","offset":5886},{"uri":"Table_(information)","surface_form":"tables","offset":5938}]}