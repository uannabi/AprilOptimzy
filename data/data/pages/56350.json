{"id":56350,"url":"http://en.wikipedia.org/wiki/Lambda_calculus","text":"In mathematical logic and computer science, lambda calculus, also \u03BB-calculus, is a formal system. It was designed to investigate the definition of functions, and how to apply them. It is also a tool for analysing recursion. It was introduced by Alonzo Church and Stephen Cole Kleene in the 1930s. Church used lambda calculus in 1936 to give a negative answer to the Entscheidungsproblem.\nLambda calculus can be used to define what is a computable function. No general algorithm can answer the question of whether two lambda calculus expressions are equivalent. This was the first question, even before the halting problem, for which undecidability could be proved. Lambda calculus has greatly influenced functional programming languages, such as LISP, ML and Haskell.\nLambda calculus can be called the smallest universal programming language. It consists of just one transformation rule (variable substitution) and just one way to define a function. Each \"function definition\" comes together with a list of the function's parameters, i.e. variables that can be used inside that definition. \"Variable substitution\" means substitution of values for variables, that is, a transformation step where an application of a function to some arguments is replaced with that function's definition in which all variables (that appear in its list of parameters) are replaced with arguments used in that application.\nLambda calculus is universal in the sense that any computable function can be expressed and evaluated using this formalism. It is thus the same as the Turing machine formalism. However, lambda calculus emphasizes the use of transformation rules. It does not care about the actual machine that implements them. It is an approach more related to software than to hardware.","categories":[],"infobox_types":[],"annotations":[{"uri":"Logic","surface_form":"mathematical logic","offset":3},{"uri":"Computer_science","surface_form":"computer science","offset":26},{"uri":"Formal_system","surface_form":"formal system","offset":83},{"uri":"Function_(mathematics)","surface_form":"functions","offset":147},{"uri":"Recursion","surface_form":"recursion","offset":213},{"uri":"Alonzo_Church","surface_form":"Alonzo Church","offset":245},{"uri":"Stephen_Cole_Kleene","surface_form":"Stephen Cole Kleene","offset":263},{"uri":"1930s","surface_form":"1930s","offset":290},{"uri":"Entscheidungsproblem","surface_form":"Entscheidungsproblem","offset":366},{"uri":"Computable_function","surface_form":"computable function","offset":436},{"uri":"Algorithm","surface_form":"algorithm","offset":468},{"uri":"Halting_problem","surface_form":"halting problem","offset":606},{"uri":"Decision_problem","surface_form":"undecidability","offset":633},{"uri":"Functional_programming","surface_form":"functional programming languages","offset":704},{"uri":"LISP","surface_form":"LISP","offset":746},{"uri":"ML_(programming_language)","surface_form":"ML","offset":752},{"uri":"Haskell_(programming_language)","surface_form":"Haskell","offset":759},{"uri":"Programming_language","surface_form":"programming language","offset":821},{"uri":"Turing_machine","surface_form":"Turing machine","offset":1554},{"uri":"Software","surface_form":"software","offset":1747},{"uri":"Computer_hardware","surface_form":"hardware","offset":1764}]}